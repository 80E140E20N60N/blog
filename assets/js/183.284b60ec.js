(window.webpackJsonp=window.webpackJsonp||[]).push([[183],{604:function(t,e,r){"use strict";r.r(e);var v=r(23),s=Object(v.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"计算属性-vs-方法-vs-侦听属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#计算属性-vs-方法-vs-侦听属性"}},[t._v("#")]),t._v(" 计算属性 vs 方法 vs 侦听属性")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%BC%93%E5%AD%98-vs-%E6%96%B9%E6%B3%95",target:"_blank",rel:"noopener noreferrer"}},[t._v("API"),r("OutboundLink")],1)]),t._v(" "),r("p",[t._v("如果一个功能同时可以使用计算属性(computed)、方法(methods)、侦听属性(watch)来实现的时候推荐使用计算属性。\n")]),t._v(" "),r("table",[r("thead",[r("tr",[r("th",[t._v("计算属性")]),t._v(" "),r("th",[t._v("方法")]),t._v(" "),r("th",[t._v("侦听属性")])])]),t._v(" "),r("tbody",[r("tr",[r("td",[t._v("计算属性是基于它们的响应式依赖进行缓存的")]),t._v(" "),r("td",[t._v("每当触发重新渲染时，调用方法将"),r("strong",[t._v("总会")]),t._v("再次执行函数")]),t._v(" "),r("td",[t._v("有缓存，但相比计算属性，实现起来要复杂很多。")])])])]),t._v(" "),r("h2",{attrs:{id:"计算属性实现的原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#计算属性实现的原理"}},[t._v("#")]),t._v(" 计算属性实现的原理")]),t._v(" "),r("p",[t._v("computed watcher, 计算属性的监听器"),r("br"),t._v("\ncomputed watcher 持有一个dep实例，通过dirty属性标记计算属性是否需要重新进行求值"),r("br"),t._v("\n当computed的依赖值改变后，就会通知订阅的watcher进行更新，对于computed watcher会将dirty属性设置为true,并且进行计算属性方法的调用")]),t._v(" "),r("ol",[r("li",[t._v("computed所谓的缓存是指什么？\n计算属性是基于它的响应式依赖进行缓存的，只有依赖发生改变时才会重新求值")]),t._v(" "),r("li",[t._v("那computed缓存存在的意义是什么？或者说经常在什么地方用？\n当计算属性方法内部操作非常耗时，比如遍历一个很大的数据，计算一次可能耗时1s")])])])}),[],!1,null,null,null);e.default=s.exports}}]);