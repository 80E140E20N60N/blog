(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{528:function(t,v,_){"use strict";_.r(v);var a=_(23),r=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),_("h2",{attrs:{id:"原始类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原始类型"}},[t._v("#")]),t._v(" 原始类型")]),t._v(" "),_("ol",[_("li",[t._v("Number")]),t._v(" "),_("li",[t._v("String")]),t._v(" "),_("li",[t._v("Bollen")]),t._v(" "),_("li",[t._v("symbol")]),t._v(" "),_("li",[t._v("null")]),t._v(" "),_("li",[t._v("undefined")])]),t._v(" "),_("p",[t._v("注：")]),t._v(" "),_("ul",[_("li",[t._v("原始类型的值无法更改，所以原始类型的相关方法只会返回新的值，而不会修改旧值")]),t._v(" "),_("li",[t._v("比较原始类型是否相等，是比较它们的值")]),t._v(" "),_("li",[t._v("复制原始类型的变量的值时，会将值拷贝一份，和原来的值是独立的")])]),t._v(" "),_("h2",{attrs:{id:"对象类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#对象类型"}},[t._v("#")]),t._v(" 对象类型")]),t._v(" "),_("p",[t._v("对象类型也叫引用类型，当给一个变量赋值为对象时，这个变量保存的是该对象在内存中的地址"),_("br"),t._v("\n注：")]),t._v(" "),_("ul",[_("li",[t._v("对象类型的值是可以修改的")]),t._v(" "),_("li",[t._v("比较原始类型是否相等，不是比较它们的值，而是比较引用地址，当且仅当它们引用的是同一个对象时，它们才相等")]),t._v(" "),_("li",[t._v("复制对象类型的变量的值时，会将存储在变量中的值拷贝一份，即拷贝的是对象在内存中的地址值，复制结束后，新旧变量指向同一个对象")]),t._v(" "),_("li",[t._v("如果想复制对象的副本，需要复制对象的每个属性，即实现深拷贝")])]),t._v(" "),_("h2",{attrs:{id:"类型转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类型转换"}},[t._v("#")]),t._v(" 类型转换")]),t._v(" "),_("h3",{attrs:{id:"转字符串"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#转字符串"}},[t._v("#")]),t._v(" 转字符串")]),t._v(" "),_("p",[t._v("运算符 + 号： + 运算存在非数字类型的值，可以将其转为字符串进行拼接")])])}),[],!1,null,null,null);v.default=r.exports}}]);